# `Y86-64 RTL`级实现

体系结构对于指令的处理分成一个个阶段，`Y86-64`指令的执行分为如下几个阶段：

> - **取指**： 从内存读取指令字节，内存地址为PC指向的值，这个字节分为高四位和低四位两个部分，分别代表`icode(指令代码)`和`ifun(指令功能)`,可能会再取出一个字节，这个字节的高四位和低四位分别指明寄存器的编号
> - **译码：**从寄存器文件读入最多两个**操作数**，放入`varA, varB`之中，也可能会取出一个八字常数放入`varC`, 下一条指令的地址放入`varP`
> - **执行**：执行相应的操作，在算数/逻辑单元`ALU`中执行指令指明的相关操作，计算内存引用的有效地址，增加或减少栈指针，得到的值放入`varE`, 于此同时，他可能会设置条件码。==对于一条传送指令来说，这个阶段会检验条件码和传送条件==，条件成立的话会更新目标寄存器
> - **访存**：访存阶段可以将数据写入内存，或者从内存读出数据，读取到`valM`
> - **写回：**该阶段最多可以写两个结果到寄存器
> - **更新PC：** 将PC设置成下一条指令的地址

处理器无限循环，执行这些阶段 在我们简化的实现中，发生任何异常时，处理器就会停止(现阶段而言)：它执行 halt 指令或非法指令，或它试图读或者写非法地址 在更完整的设计中，处理器会进入异常处理模式，开始执行由异常的类型决定的特殊代码。

## 顺序实现的`Y86-64`处理器

`Y86-64`指令的执行分为如下几个阶段，假设`Y86-64`的每一个指令的执行都在一个时钟周期内完成，称为`sequential`顺序处理`SEQ`，当然一个指令周期的频率必然就很低，这需要一个很长的时钟周期。

## 流水线的`Y86-64`处理器

## `Y86-64`每一种指令执行的阶段示意

![image-20221011232602708](D:\ClionProject\ISA-Y86-64\doc\Y8664_rtl_design.assets\image-20221011232602708.png)

![image-20221011232821231](D:\ClionProject\ISA-Y86-64\doc\Y8664_rtl_design.assets\image-20221011232821231.png)

![image-20221011232839458](D:\ClionProject\ISA-Y86-64\doc\Y8664_rtl_design.assets\image-20221011232839458.png)

![image-20221011232925981](D:\ClionProject\ISA-Y86-64\doc\Y8664_rtl_design.assets\image-20221011232925981.png)

![image-20221011233019958](D:\ClionProject\ISA-Y86-64\doc\Y8664_rtl_design.assets\image-20221011233019958.png)

![image-20221011232937551](D:\ClionProject\ISA-Y86-64\doc\Y8664_rtl_design.assets\image-20221011232937551.png)

