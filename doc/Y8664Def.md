# Y86-64指令集架构

## Overview

`Y86-64`是《深入理解计算机操作系统》书中定义的一个简单的体系结构，用于学习理解

## Y86-64

### 寄存器、内存、程序状态码

- 寄存器

Y86-64有`15个`寄存器, 每个寄存器存储一个`64`位的字，如下。寄存器除了`%rsp`用于==入栈、出战、调用和返回指令作为栈指针==， 其他寄存器没有特定的含义， 还包含三个状态码`ZF, SF, OF`, 以及一个程序计数器`PC`存放当前正在执行指令的下一条指令的地址

| %rax | %rsp | %r8  | %r12 |
| ---- | ---- | ---- | ---- |
| %rcx | %rbp | %r9  | %r13 |
| %rdx | %rsi | %r10 | %r14 |
| %rbx | %rdi | %r11 |      |

- 内存
- 程序状态码`Stat`, 指示程序正常运行还是出现了某种异常

### 指令

Y86-64是X86-64指令的子集

- 只包括8字节的整数操作
- 寻址方式少，操作数少

> 1. `movq`指令分成四个不同的指令: `irmovq, rrmovq, mrmovq和rmmovq`, 前面两个字母分别制定了从源操作数和目的操作数的格式，`i代表立即数`，`r代表寄存器`，`m代表内存`，==支持基址个偏移量的计算，不支持第二变址寄存器和任何变址寄存器值的伸缩，同时页不支持内存到内存值的直接传递以及立即数到内存值的传递==
>
> 2. 4个整数操作数指令==(OPq)==`addq, subq, andq, xorq` ==只允许对寄存器进行操作==, 同时会置位`ZF, SF, OF`三个标识码(零、符号、溢出)
> 3. 7个跳转指令分别是`jmp, jle, jl, je, jne, jqe, jq`分支条件与X86-64一样
> 4. 6个条件传送指令==(cmovXX)== `cmovle, cmovl, cmovez, cmovne, cmovge, cmovg`, 这些寄存器与寄存器之间的条件传送，只有当条件码满足的时候才会更新值 
> 5. `call`指令将返回地址入栈，跳到目的地址，`ret`指令从栈中弹出，更新PC的值
> 6. `pushq, popq`指令实现入栈和出栈，和X86-64一样
> 7. `halt`指令停止指令的执行，状态码设置为`HLT`

[Y86-64](./doc/y8664.xslx)

